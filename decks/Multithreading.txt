ID: 1e1f0f87-ce2f-4a57-a525-68e548d6e3b4
CATEGORY: Multithreading
QUESTION:
В чем разница между Процессом и Потоком (Thread)?
ANSWER:
Процесс: Экземпляр запущенной программы. Имеет собственное адресное пространство памяти, изолирован от других процессов. Тяжеловесный.
Поток: Легковесный подпроцесс внутри процесса. Делит память (Heap) и ресурсы с другими потоками того же процесса. Переключение контекста между потоками дешевле, чем между процессами.
===
ID: 82fe3ed5-4edf-4525-87fe-183c3f109d63
CATEGORY: Multithreading
QUESTION:
Как создать поток в Java?
ANSWER:
Наследоваться от класса Thread и переопределить run().
Реализовать интерфейс Runnable и передать его в конструктор Thread.
(Предпочтительно) Использовать ExecutorService и передавать задачи (Runnable / Callable).
===
ID: 9218c765-31b2-4757-ad98-a348bd0d0777
CATEGORY: Multithreading
QUESTION:
Что такое методы start() и run()? В чем разница?
ANSWER:
start(): Создает новый системный поток, выделяет ему стек и затем вызывает метод run() в этом новом потоке.
run(): Просто выполняет код в текущем потоке (как обычный метод). Многопоточности не возникает.
===
ID: b2538384-534f-4690-bc65-9ef0acd84cde
CATEGORY: Multithreading
QUESTION:
Жизненный цикл потока (Thread States) в Java.
ANSWER:
NEW: Создан, но не запущен (start() не вызван).
RUNNABLE: Выполняется (или готов к выполнению и ждет процессор).
BLOCKED: Ждет захвата монитора (блокировки) synchronized.
WAITING: Ждет сигнала от другого потока (wait, join).
TIMED_WAITING: Ждет с тайм-аутом (sleep, wait(ms)).
TERMINATED: Завершил выполнение.
===
ID: 2e111f7a-7c62-458f-be01-73aa048a039a
CATEGORY: Multithreading
QUESTION:
Что такое Daemon-потоки? Чем они отличаются от User-потоков?
ANSWER:
Daemon: Служебные потоки (например, GC). JVM завершает работу, как только все User-потоки завершились, не дожидаясь демонов (они убиваются принудительно).
User: Основные потоки приложения. JVM работает, пока жив хотя бы один User-поток.
===
ID: 15d79f3c-dd9c-4a3d-85ab-17b2f45a433a
CATEGORY: Multithreading
QUESTION:
Что такое Race Condition (Состояние гонки)?
ANSWER:
Ошибка проектирования многопоточной системы, когда работа программы зависит от некорректного порядка выполнения потоков (например, операция "прочитать-изменить-записать" не атомарна). Пример: count++.
===
ID: 9350677e-a224-4f38-9b77-59e9e509d38f
CATEGORY: Multithreading
QUESTION:
Что такое Data Race? Отличие от Race Condition.
ANSWER:
Data Race: Одновременный доступ (без синхронизации) к одной и той же ячейке памяти из разных потоков, где хотя бы один доступ — это запись. Это нарушение JMM.
Race Condition — более широкое понятие, ошибка логики. Data Race — конкретная проблема доступа к памяти.
===
ID: d692b90f-fa47-4d0b-a3a5-a58a21a8269f
CATEGORY: Multithreading
QUESTION:
Что такое Deadlock (Взаимная блокировка)?
ANSWER:
Ситуация, когда два или более потока вечно ждут друг друга, удерживая ресурсы, необходимые друг другу.
Пример: Поток A держит Лок 1 и ждет Лок 2. Поток B держит Лок 2 и ждет Лок 1.
===
ID: 41b4d246-1ec0-40d4-8a4e-076af89a8af2
CATEGORY: Multithreading
QUESTION:
Как избежать Deadlock?
ANSWER:
Захватывать ресурсы (локи) всегда в одном и том же фиксированном порядке.
Использовать tryLock() с тайм-аутом (из ReentrantLock).
Не вызывать "чужие" методы внутри синхронизированного блока.
===
ID: 30cb3fcc-275e-4b65-9dbd-db494da402b4
CATEGORY: Multithreading
QUESTION:
Что такое Livelock и Starvation?
ANSWER:
Livelock: Потоки не заблокированы, но постоянно меняют свое состояние в ответ на действия друг друга, не совершая полезной работы (как два человека в коридоре, уступающие друг другу дорогу).
Starvation (Голодание): Поток не может получить доступ к ресурсу (CPU, лок) долгое время, так как его постоянно перехватывают более приоритетные потоки.
===
ID: e1f6f120-e3f3-4808-b7af-9edb566880ca
CATEGORY: Java Memory Model
QUESTION:
Что такое JMM (Java Memory Model)?
ANSWER:
Спецификация, описывающая, как потоки взаимодействуют через память. Определяет правила видимости (visibility), атомарности и упорядочивания (ordering) инструкций.
===
ID: e8738d07-f8d0-453b-8984-0f50b6949813
CATEGORY: Java Memory Model
QUESTION:
Что такое отношение Happens-Before?
ANSWER:
Ключевое понятие JMM. Если действие A happens-before B, то результаты A гарантированно видны в B.
Примеры:
Запись в volatile happens-before чтение из него.
Освобождение монитора (unlock) happens-before захват (lock).
Thread.start() happens-before начало run().
===
ID: 41e54336-7b3b-48ea-b60e-a2c0283e50d0
CATEGORY: Java Memory Model
QUESTION:
Зачем нужен volatile?
ANSWER:
Видимость (Visibility): Гарантирует, что изменение переменной одним потоком будет мгновенно видно всем другим потокам (запись идет в основную память, минуя кэши CPU).
Запрет переупорядочивания (Ordering): Инструкции не могут быть переставлены компилятором/CPU относительно доступа к volatile переменной.
Важно: НЕ гарантирует атомарность (не подходит для i++).
===
ID: 5bd7b2b0-0bd0-4546-8505-76b1b587c3fc
CATEGORY: Multithreading
QUESTION:
Что такое атомарность операции? Является ли long и double атомарными?
ANSWER:
Атомарность — операция выполняется целиком или не выполняется вовсе, её нельзя прервать посередине.
Чтение/запись long и double (64 бит) в 32-битных системах НЕ атомарны (могут записаться две половинки по 32 бита). Нужно использовать volatile. В 64-битных JVM обычно атомарны, но гарантии дает только volatile.
Переходим к блоку Синхронизация и java.util.concurrent. Здесь обсуждаются способы борьбы с проблемами многопоточности.
===
ID: b6ec099c-ae2c-4bf3-a815-9ede926ee2bc
CATEGORY: Multithreading
QUESTION:
Что такое монитор в Java?
ANSWER:
Механизм синхронизации, встроенный в каждый объект Java. Используется ключевым словом synchronized. Позволяет только одному потоку одновременно владеть блокировкой объекта.
===
ID: f25acb2d-aaff-4f12-9a76-4318eb1f4c4b
CATEGORY: Multithreading
QUESTION:
Как работает synchronized? Разница между синхронизацией метода и блока.
ANSWER:
Метод (synchronized void m()): захватывает монитор this (для instance-методов) или Class (для static).
Блок (synchronized(obj) { ... }): захватывает монитор указанного объекта obj. Блок гибче (меньше область синхронизации, можно выбрать объект лока).
===
ID: 0e959bb5-9918-473d-a5fe-531cf9256495
CATEGORY: Multithreading
QUESTION:
Методы wait(), notify(), notifyAll(). Где находятся, зачем нужны, правила использования.
ANSWER:
Находятся в классе Object. Нужны для координации потоков (ожидание условия).
Правило: должны вызываться ТОЛЬКО внутри синхронизированного блока/метода по тому же объекту. Иначе IllegalMonitorStateException.
wait() освобождает монитор и ждет. notify() будит один случайный поток.
===
ID: 63cbc400-5fb2-45e3-ae00-7a3645706122
CATEGORY: Multithreading
QUESTION:
Что такое Spurious Wakeup (Ложное пробуждение)?
ANSWER:
Ситуация, когда поток просыпается из wait() без вызова notify().
Решение: всегда вызывать wait() внутри цикла while (conditionIsNotMet), чтобы после пробуждения перепроверить условие.
===
ID: bfd597ec-03e1-4720-8337-b5423e62ce2d
CATEGORY: java.util.concurrent
QUESTION:
Что такое Atomic классы (AtomicInteger, AtomicReference)?
ANSWER:
Классы, обеспечивающие атомарные операции над переменными без использования блокировок (synchronized).
Используют процессорную инструкцию CAS (Compare-And-Swap).
===
ID: 413107be-3aeb-4a15-8e11-e9ea70ceca91
CATEGORY: java.util.concurrent
QUESTION:
Что такое CAS (Compare-And-Swap)?
ANSWER:
Оптимистичный алгоритм блокировки. Атомарная инструкция: "Если текущее значение равно X, запиши Y". Если значение успело измениться другим потоком, операция не выполняется (возвращает false), и мы пробуем снова в цикле.
===
ID: b881b27d-6643-4820-b8bd-6afe32ef4b43
CATEGORY: java.util.concurrent
QUESTION:
ReentrantLock vs synchronized. В чем преимущества лока?
ANSWER:
ReentrantLock — это явная блокировка.
Преимущества:
tryLock() (попытка захватить лок без ожидания или с тайм-аутом).
lockInterruptibly() (можно прервать ожидание лока).
Fair lock (честная очередь ожидания).
Разделение Condition (несколько условий ожидания на один лок).
===
ID: 03e7ab30-0dda-424d-938d-37aab60e332e
CATEGORY: java.util.concurrent
QUESTION:
Что такое CountDownLatch?
ANSWER:
Синхронизатор, позволяющий одному или нескольким потокам ждать, пока завершится определенное количество операций в других потоках. (Обратный отсчет до нуля). Одноразовый.
===
ID: 00be19e7-e65e-4c98-a142-ab7ee640ccae
CATEGORY: java.util.concurrent
QUESTION:
Что такое CyclicBarrier?
ANSWER:
Точка синхронизации, в которой должны собраться N потоков, прежде чем они все смогут продолжить выполнение. Многоразовый (циклический).
===
ID: fa0b8c27-30c5-4471-a58e-d980a3fc9582
CATEGORY: java.util.concurrent
QUESTION:
Что такое Semaphore?
ANSWER:
Синхронизатор, ограничивающий количество потоков, которые могут одновременно получить доступ к ресурсу. Использует счетчик разрешений (permits). acquire() уменьшает, release() увеличивает.
===
ID: 40bb60fe-cfb3-4546-81a8-401d501955ba
CATEGORY: java.util.concurrent
QUESTION:
Что такое ThreadLocal?
ANSWER:
Класс, позволяющий создавать переменные, которые доступны только конкретному потоку (у каждого потока своя копия). Используется для хранения контекста (например, транзакции, User ID) без передачи параметров.
Внимание: может вызывать утечки памяти в пулах потоков, если не очищать (remove()).
===
ID: 07fd3221-ac4c-4323-9ac0-96973f3be841
CATEGORY: java.util.concurrent
QUESTION:
В чем разница между ConcurrentHashMap, Hashtable и Collections.synchronizedMap?
ANSWER:
Hashtable / synchronizedMap: Блокируют всю мапу целиком на каждую операцию (низкая производительность).
ConcurrentHashMap: Блокирует только часть мапы (сегмент/бакет) при записи. Чтение вообще без блокировок. Использует CAS. Намного быстрее в многопоточной среде.
===
ID: 58349427-5df4-4599-a640-823d51e58461
CATEGORY: java.util.concurrent
QUESTION:
Что такое BlockingQueue?
ANSWER:
Потокобезопасная очередь. Методы put() (блокируется, если очередь полна) и take() (блокируется, если очередь пуста).
Идеальна для паттерна Producer-Consumer.
Переходим к последнему блоку многопоточности — Высокоуровневые абстракции (Advanced Concurrency). Это то, что используется в реальной разработке чаще всего.
===
ID: 8d40d7d4-d707-4977-8414-22f7886a2144
CATEGORY: Advanced Concurrency
QUESTION:
Что такое ExecutorService? Зачем он нужен?
ANSWER:
Интерфейс для управления пулом потоков. Абстрагирует создание и управление жизненным циклом потоков.
Зачем: создание потока — дорогая операция. Пул позволяет переиспользовать потоки для множества задач.
===
ID: f6ab30f4-bd85-4f3d-b7fe-ca210bd20918
CATEGORY: Advanced Concurrency
QUESTION:
В чем разница между submit() и execute() в ExecutorService?
ANSWER:
execute(Runnable): ничего не возвращает. Если задача упадет с исключением, мы об этом можем не узнать (зависит от настроек).
submit(Runnable/Callable): возвращает Future. Позволяет получить результат или перехватить исключение при вызове future.get().
===
ID: 7ecbdf13-0b37-46bf-b944-2c99ef24732a
CATEGORY: Advanced Concurrency
QUESTION:
Виды пулов потоков (Executors).
ANSWER:
FixedThreadPool(n): фиксированное число потоков.
CachedThreadPool(): создает новые потоки по необходимости, убивает простаивающие (опасно при неконтролируемом потоке задач).
SingleThreadExecutor(): один поток (очередь задач).
ScheduledThreadPool(): для отложенных/периодических задач.
===
ID: d28a4483-74db-499b-998e-ef0147c92c1e
CATEGORY: Advanced Concurrency
QUESTION:
Что такое Future? Его недостатки.
ANSWER:
Объект, представляющий результат асинхронной операции, который будет получен в будущем.
Недостатки: метод get() блокирующий. Нельзя удобно комбинировать несколько Future, нельзя вручную завершить (до Java 8).
===
ID: 65599dca-e91f-49bf-9463-1e8c7d82af1c
CATEGORY: Advanced Concurrency
QUESTION:
Что такое CompletableFuture?
ANSWER:
Улучшенная версия Future (Java 8). Позволяет строить цепочки асинхронных операций (thenApply, thenCompose), обрабатывать исключения, комбинировать результаты без блокировки основного потока.
===
ID: 578f499c-c07d-44b3-a383-6889fda442ec
CATEGORY: Advanced Concurrency
QUESTION:
Что такое ForkJoinPool?
ANSWER:
Специализированный пул для задач типа "Разделяй и властвуй" (рекурсивное деление). Использует алгоритм Work Stealing (свободные потоки крадут задачи из хвоста очереди занятых потоков). Используется по умолчанию в parallelStream().
===
ID: d260dc4b-3bc1-4b62-b4ef-8a995d5db1ba
CATEGORY: Advanced Concurrency
QUESTION:
Что такое Виртуальные потоки (Virtual Threads / Project Loom)?
ANSWER:
Введены в Java 21. Легковесные потоки, управляемые JVM, а не ОС.
Позволяют создавать миллионы потоков. Блокировка виртуального потока (I/O) не блокирует системный поток (carrier thread).
Идеальны для стиля "thread-per-request" в I/O-bound задачах.
===
ID: a2ea4eae-5a01-4ec7-a1ca-33d133de347f
CATEGORY: Advanced Concurrency
QUESTION:
В чем отличие I/O-bound от CPU-bound задач? Где помогут Виртуальные потоки?
ANSWER:
I/O-bound: ожидание ввода-вывода (сеть, БД, диск). Поток простаивает. -> Виртуальные потоки идеальны.
CPU-bound: активные вычисления (математика, криптография). Процессор загружен. -> Виртуальные потоки не дают выигрыша (лучше обычный пул размером с число ядер).
===
ID: 17f3129b-1b00-4c2a-b3ea-0c4ee3c468f6
CATEGORY: Advanced Concurrency
QUESTION:
Что такое Structured Concurrency (Структурированная многопоточность)?
ANSWER:
Новый подход (в превью), где связанные задачи, запущенные в разных потоках, рассматриваются как единый блок работы. Если одна подзадача падает, остальные корректно отменяются. Упрощает обработку ошибок и отмену.
===
ID: 1cb7acf2-5d84-4c05-9307-781aab75b888
CATEGORY: Multithreading
QUESTION:
Что такое Double-Checked Locking? Почему он не работал до Java 5?
ANSWER:
Паттерн ленивой инициализации синглтона.
До Java 5 (`volatile` семантика была слабой) была возможна ситуация, когда ссылка на объект уже не null, но конструктор еще не завершился (инструкции переставились). Другой поток мог получить "полуинициализированный" объект и упасть.
С Java 5 (volatile happens-before) это работает корректно.
===
ID: 062f8d92-2fea-48f4-bf91-50eb173cf8e2
CATEGORY: Multithreading
QUESTION:
Что такое `Thread.join()`?
ANSWER:
Метод, который заставляет текущий поток ждать завершения того потока, у которого вызван `join()`.
`t1.join()` — "я (текущий поток) подожду, пока t1 умрет".
===
ID: ef50ded0-a857-457c-bcc9-8bbf0b22f389
CATEGORY: Multithreading
QUESTION:
В чем опасность метода `Thread.stop()`?
ANSWER:
Он устарел (Deprecated). Он насильно убивает поток в любой момент, даже посередине операции. Это может оставить объекты в несогласованном состоянии ("битые" данные), не освободить мониторы и привести к непредсказуемым ошибкам.
Вместо него используют `interrupt()`.
===
ID: e3faf8d3-27a8-4913-b92c-a22659babf24
CATEGORY: Multithreading
QUESTION:
Что такое "Happens-Before" ребро в графе выполнения?
ANSWER:
Отношение частичного порядка. Если действие A happens-before B, то B гарантированно видит все изменения памяти, сделанные A.
Транзитивность: Если A hb B, и B hb C, то A hb C.
===
