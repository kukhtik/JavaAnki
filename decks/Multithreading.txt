CATEGORY: Multithreading
QUESTION:
В чем разница между Процессом и Потоком (Thread)?
ANSWER:
Процесс: Экземпляр запущенной программы. Имеет собственное адресное пространство памяти, изолирован от других процессов. Тяжеловесный.
Поток: Легковесный подпроцесс внутри процесса. Делит память (Heap) и ресурсы с другими потоками того же процесса. Переключение контекста между потоками дешевле, чем между процессами.
===
CATEGORY: Multithreading
QUESTION:
Как создать поток в Java?
ANSWER:
Наследоваться от класса Thread и переопределить run().
Реализовать интерфейс Runnable и передать его в конструктор Thread.
(Предпочтительно) Использовать ExecutorService и передавать задачи (Runnable / Callable).
===
CATEGORY: Multithreading
QUESTION:
Что такое методы start() и run()? В чем разница?
ANSWER:
start(): Создает новый системный поток, выделяет ему стек и затем вызывает метод run() в этом новом потоке.
run(): Просто выполняет код в текущем потоке (как обычный метод). Многопоточности не возникает.
===
CATEGORY: Multithreading
QUESTION:
Жизненный цикл потока (Thread States) в Java.
ANSWER:
NEW: Создан, но не запущен (start() не вызван).
RUNNABLE: Выполняется (или готов к выполнению и ждет процессор).
BLOCKED: Ждет захвата монитора (блокировки) synchronized.
WAITING: Ждет сигнала от другого потока (wait, join).
TIMED_WAITING: Ждет с тайм-аутом (sleep, wait(ms)).
TERMINATED: Завершил выполнение.
===
CATEGORY: Multithreading
QUESTION:
Что такое Daemon-потоки? Чем они отличаются от User-потоков?
ANSWER:
Daemon: Служебные потоки (например, GC). JVM завершает работу, как только все User-потоки завершились, не дожидаясь демонов (они убиваются принудительно).
User: Основные потоки приложения. JVM работает, пока жив хотя бы один User-поток.
===
CATEGORY: Multithreading
QUESTION:
Что такое Race Condition (Состояние гонки)?
ANSWER:
Ошибка проектирования многопоточной системы, когда работа программы зависит от некорректного порядка выполнения потоков (например, операция "прочитать-изменить-записать" не атомарна). Пример: count++.
===
CATEGORY: Multithreading
QUESTION:
Что такое Data Race? Отличие от Race Condition.
ANSWER:
Data Race: Одновременный доступ (без синхронизации) к одной и той же ячейке памяти из разных потоков, где хотя бы один доступ — это запись. Это нарушение JMM.
Race Condition — более широкое понятие, ошибка логики. Data Race — конкретная проблема доступа к памяти.
===
CATEGORY: Multithreading
QUESTION:
Что такое Deadlock (Взаимная блокировка)?
ANSWER:
Ситуация, когда два или более потока вечно ждут друг друга, удерживая ресурсы, необходимые друг другу.
Пример: Поток A держит Лок 1 и ждет Лок 2. Поток B держит Лок 2 и ждет Лок 1.
===
CATEGORY: Multithreading
QUESTION:
Как избежать Deadlock?
ANSWER:
Захватывать ресурсы (локи) всегда в одном и том же фиксированном порядке.
Использовать tryLock() с тайм-аутом (из ReentrantLock).
Не вызывать "чужие" методы внутри синхронизированного блока.
===
CATEGORY: Multithreading
QUESTION:
Что такое Livelock и Starvation?
ANSWER:
Livelock: Потоки не заблокированы, но постоянно меняют свое состояние в ответ на действия друг друга, не совершая полезной работы (как два человека в коридоре, уступающие друг другу дорогу).
Starvation (Голодание): Поток не может получить доступ к ресурсу (CPU, лок) долгое время, так как его постоянно перехватывают более приоритетные потоки.
===
CATEGORY: Java Memory Model
QUESTION:
Что такое JMM (Java Memory Model)?
ANSWER:
Спецификация, описывающая, как потоки взаимодействуют через память. Определяет правила видимости (visibility), атомарности и упорядочивания (ordering) инструкций.
===
CATEGORY: Java Memory Model
QUESTION:
Что такое отношение Happens-Before?
ANSWER:
Ключевое понятие JMM. Если действие A happens-before B, то результаты A гарантированно видны в B.
Примеры:
Запись в volatile happens-before чтение из него.
Освобождение монитора (unlock) happens-before захват (lock).
Thread.start() happens-before начало run().
===
CATEGORY: Java Memory Model
QUESTION:
Зачем нужен volatile?
ANSWER:
Видимость (Visibility): Гарантирует, что изменение переменной одним потоком будет мгновенно видно всем другим потокам (запись идет в основную память, минуя кэши CPU).
Запрет переупорядочивания (Ordering): Инструкции не могут быть переставлены компилятором/CPU относительно доступа к volatile переменной.
Важно: НЕ гарантирует атомарность (не подходит для i++).
===
CATEGORY: Multithreading
QUESTION:
Что такое атомарность операции? Является ли long и double атомарными?
ANSWER:
Атомарность — операция выполняется целиком или не выполняется вовсе, её нельзя прервать посередине.
Чтение/запись long и double (64 бит) в 32-битных системах НЕ атомарны (могут записаться две половинки по 32 бита). Нужно использовать volatile. В 64-битных JVM обычно атомарны, но гарантии дает только volatile.
Переходим к блоку Синхронизация и java.util.concurrent. Здесь обсуждаются способы борьбы с проблемами многопоточности.
===
CATEGORY: Multithreading
QUESTION:
Что такое монитор в Java?
ANSWER:
Механизм синхронизации, встроенный в каждый объект Java. Используется ключевым словом synchronized. Позволяет только одному потоку одновременно владеть блокировкой объекта.
===
CATEGORY: Multithreading
QUESTION:
Как работает synchronized? Разница между синхронизацией метода и блока.
ANSWER:
Метод (synchronized void m()): захватывает монитор this (для instance-методов) или Class (для static).
Блок (synchronized(obj) { ... }): захватывает монитор указанного объекта obj. Блок гибче (меньше область синхронизации, можно выбрать объект лока).
===
CATEGORY: Multithreading
QUESTION:
Методы wait(), notify(), notifyAll(). Где находятся, зачем нужны, правила использования.
ANSWER:
Находятся в классе Object. Нужны для координации потоков (ожидание условия).
Правило: должны вызываться ТОЛЬКО внутри синхронизированного блока/метода по тому же объекту. Иначе IllegalMonitorStateException.
wait() освобождает монитор и ждет. notify() будит один случайный поток.
===
CATEGORY: Multithreading
QUESTION:
Что такое Spurious Wakeup (Ложное пробуждение)?
ANSWER:
Ситуация, когда поток просыпается из wait() без вызова notify().
Решение: всегда вызывать wait() внутри цикла while (conditionIsNotMet), чтобы после пробуждения перепроверить условие.
===
CATEGORY: java.util.concurrent
QUESTION:
Что такое Atomic классы (AtomicInteger, AtomicReference)?
ANSWER:
Классы, обеспечивающие атомарные операции над переменными без использования блокировок (synchronized).
Используют процессорную инструкцию CAS (Compare-And-Swap).
===
CATEGORY: java.util.concurrent
QUESTION:
Что такое CAS (Compare-And-Swap)?
ANSWER:
Оптимистичный алгоритм блокировки. Атомарная инструкция: "Если текущее значение равно X, запиши Y". Если значение успело измениться другим потоком, операция не выполняется (возвращает false), и мы пробуем снова в цикле.
===
CATEGORY: java.util.concurrent
QUESTION:
ReentrantLock vs synchronized. В чем преимущества лока?
ANSWER:
ReentrantLock — это явная блокировка.
Преимущества:
tryLock() (попытка захватить лок без ожидания или с тайм-аутом).
lockInterruptibly() (можно прервать ожидание лока).
Fair lock (честная очередь ожидания).
Разделение Condition (несколько условий ожидания на один лок).
===
CATEGORY: java.util.concurrent
QUESTION:
Что такое CountDownLatch?
ANSWER:
Синхронизатор, позволяющий одному или нескольким потокам ждать, пока завершится определенное количество операций в других потоках. (Обратный отсчет до нуля). Одноразовый.
===
CATEGORY: java.util.concurrent
QUESTION:
Что такое CyclicBarrier?
ANSWER:
Точка синхронизации, в которой должны собраться N потоков, прежде чем они все смогут продолжить выполнение. Многоразовый (циклический).
===
CATEGORY: java.util.concurrent
QUESTION:
Что такое Semaphore?
ANSWER:
Синхронизатор, ограничивающий количество потоков, которые могут одновременно получить доступ к ресурсу. Использует счетчик разрешений (permits). acquire() уменьшает, release() увеличивает.
===
CATEGORY: java.util.concurrent
QUESTION:
Что такое ThreadLocal?
ANSWER:
Класс, позволяющий создавать переменные, которые доступны только конкретному потоку (у каждого потока своя копия). Используется для хранения контекста (например, транзакции, User ID) без передачи параметров.
Внимание: может вызывать утечки памяти в пулах потоков, если не очищать (remove()).
===
CATEGORY: java.util.concurrent
QUESTION:
В чем разница между ConcurrentHashMap, Hashtable и Collections.synchronizedMap?
ANSWER:
Hashtable / synchronizedMap: Блокируют всю мапу целиком на каждую операцию (низкая производительность).
ConcurrentHashMap: Блокирует только часть мапы (сегмент/бакет) при записи. Чтение вообще без блокировок. Использует CAS. Намного быстрее в многопоточной среде.
===
CATEGORY: java.util.concurrent
QUESTION:
Что такое BlockingQueue?
ANSWER:
Потокобезопасная очередь. Методы put() (блокируется, если очередь полна) и take() (блокируется, если очередь пуста).
Идеальна для паттерна Producer-Consumer.
Переходим к последнему блоку многопоточности — Высокоуровневые абстракции (Advanced Concurrency). Это то, что используется в реальной разработке чаще всего.
===
CATEGORY: Advanced Concurrency
QUESTION:
Что такое ExecutorService? Зачем он нужен?
ANSWER:
Интерфейс для управления пулом потоков. Абстрагирует создание и управление жизненным циклом потоков.
Зачем: создание потока — дорогая операция. Пул позволяет переиспользовать потоки для множества задач.
===
CATEGORY: Advanced Concurrency
QUESTION:
В чем разница между submit() и execute() в ExecutorService?
ANSWER:
execute(Runnable): ничего не возвращает. Если задача упадет с исключением, мы об этом можем не узнать (зависит от настроек).
submit(Runnable/Callable): возвращает Future. Позволяет получить результат или перехватить исключение при вызове future.get().
===
CATEGORY: Advanced Concurrency
QUESTION:
Виды пулов потоков (Executors).
ANSWER:
FixedThreadPool(n): фиксированное число потоков.
CachedThreadPool(): создает новые потоки по необходимости, убивает простаивающие (опасно при неконтролируемом потоке задач).
SingleThreadExecutor(): один поток (очередь задач).
ScheduledThreadPool(): для отложенных/периодических задач.
===
CATEGORY: Advanced Concurrency
QUESTION:
Что такое Future? Его недостатки.
ANSWER:
Объект, представляющий результат асинхронной операции, который будет получен в будущем.
Недостатки: метод get() блокирующий. Нельзя удобно комбинировать несколько Future, нельзя вручную завершить (до Java 8).
===
CATEGORY: Advanced Concurrency
QUESTION:
Что такое CompletableFuture?
ANSWER:
Улучшенная версия Future (Java 8). Позволяет строить цепочки асинхронных операций (thenApply, thenCompose), обрабатывать исключения, комбинировать результаты без блокировки основного потока.
===
CATEGORY: Advanced Concurrency
QUESTION:
Что такое ForkJoinPool?
ANSWER:
Специализированный пул для задач типа "Разделяй и властвуй" (рекурсивное деление). Использует алгоритм Work Stealing (свободные потоки крадут задачи из хвоста очереди занятых потоков). Используется по умолчанию в parallelStream().
===
CATEGORY: Advanced Concurrency
QUESTION:
Что такое Виртуальные потоки (Virtual Threads / Project Loom)?
ANSWER:
Введены в Java 21. Легковесные потоки, управляемые JVM, а не ОС.
Позволяют создавать миллионы потоков. Блокировка виртуального потока (I/O) не блокирует системный поток (carrier thread).
Идеальны для стиля "thread-per-request" в I/O-bound задачах.
===
CATEGORY: Advanced Concurrency
QUESTION:
В чем отличие I/O-bound от CPU-bound задач? Где помогут Виртуальные потоки?
ANSWER:
I/O-bound: ожидание ввода-вывода (сеть, БД, диск). Поток простаивает. -> Виртуальные потоки идеальны.
CPU-bound: активные вычисления (математика, криптография). Процессор загружен. -> Виртуальные потоки не дают выигрыша (лучше обычный пул размером с число ядер).
===
CATEGORY: Advanced Concurrency
QUESTION:
Что такое Structured Concurrency (Структурированная многопоточность)?
ANSWER:
Новый подход (в превью), где связанные задачи, запущенные в разных потоках, рассматриваются как единый блок работы. Если одна подзадача падает, остальные корректно отменяются. Упрощает обработку ошибок и отмену.
===
CATEGORY: Multithreading
QUESTION:
Что такое Double-Checked Locking? Почему он не работал до Java 5?
ANSWER:
Паттерн ленивой инициализации синглтона.
До Java 5 (`volatile` семантика была слабой) была возможна ситуация, когда ссылка на объект уже не null, но конструктор еще не завершился (инструкции переставились). Другой поток мог получить "полуинициализированный" объект и упасть.
С Java 5 (volatile happens-before) это работает корректно.
===
CATEGORY: Multithreading
QUESTION:
Что такое `Thread.join()`?
ANSWER:
Метод, который заставляет текущий поток ждать завершения того потока, у которого вызван `join()`.
`t1.join()` — "я (текущий поток) подожду, пока t1 умрет".
===
CATEGORY: Multithreading
QUESTION:
В чем опасность метода `Thread.stop()`?
ANSWER:
Он устарел (Deprecated). Он насильно убивает поток в любой момент, даже посередине операции. Это может оставить объекты в несогласованном состоянии ("битые" данные), не освободить мониторы и привести к непредсказуемым ошибкам.
Вместо него используют `interrupt()`.
===
CATEGORY: Multithreading
QUESTION:
Что такое "Happens-Before" ребро в графе выполнения?
ANSWER:
Отношение частичного порядка. Если действие A happens-before B, то B гарантированно видит все изменения памяти, сделанные A.
Транзитивность: Если A hb B, и B hb C, то A hb C.
===
