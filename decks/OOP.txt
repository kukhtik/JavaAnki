CATEGORY: OOP
QUESTION:
Назовите 4 основных принципа ООП.
ANSWER:
Инкапсуляция.
Наследование.
Полиморфизм.
Абстракция.
===
CATEGORY: OOP
QUESTION:
Что такое инкапсуляция? Зачем она нужна?
ANSWER:
Сокрытие внутреннего состояния объекта и предоставление доступа к нему только через публичные методы (интерфейс).
Нужна для защиты инвариантов объекта (валидация при изменении) и уменьшения связности (можно менять реализацию, не ломая клиентский код).
===
CATEGORY: OOP
QUESTION:
Что такое наследование? Какие проблемы оно может вызвать?
ANSWER:
Механизм, позволяющий создавать новые классы на основе существующих (расширение функциональности).
Проблемы: жесткая связь (tight coupling) — изменения в родителе могут сломать потомков ("хрупкий базовый класс"), нарушение инкапсуляции родителя.
===
CATEGORY: OOP
QUESTION:
В чем разница между композицией и агрегацией?
ANSWER:
Композиция ("часть-целое", сильная связь): часть не может существовать без целого (Дом и Комната). При уничтожении целого уничтожаются части.
Агрегация ("имеет", слабая связь): часть может существовать отдельно от целого (Университет и Студент).
===
CATEGORY: OOP
QUESTION:
Наследование vs Композиция. Что и когда лучше использовать?
ANSWER:
Предпочитайте композицию наследованию (Composition over Inheritance).
Наследование: только для отношений "является" (is-a), когда поведение полностью совпадает и расширяется.
Композиция: для отношений "имеет" (has-a) или "использует", позволяет гибко менять поведение в рантайме (стратегия) и избегать проблем наследования.
===
CATEGORY: OOP
QUESTION:
Что такое полиморфизм? Какие виды бывают?
ANSWER:
Способность объектов с одинаковой спецификацией (интерфейсом) иметь разную реализацию.
Виды:
Ad-hoc (перегрузка методов).
Параметрический (Generics).
Полиморфизм подтипов (переопределение методов, override) — основной в ООП.
===
CATEGORY: OOP
QUESTION:
В чем разница между абстрактным классом и интерфейсом?
ANSWER:
Абстрактный класс: может иметь состояние (поля), конструкторы. Описывает "что это такое" (is-a). Множественное наследование классов запрещено.
Интерфейс: описывает поведение ("что умеет делать", can-do). Может иметь константы и default/static методы. Поддерживает множественную реализацию.
===
CATEGORY: OOP
QUESTION:
Что такое проблема ромбовидного наследования и как она решается в Java?
ANSWER:
Когда класс наследует два класса, имеющих общего предка, возникает неопределенность, какой метод вызывать.
В Java множественное наследование классов запрещено.
Для интерфейсов с default методами конфликт решается правилом: "класс всегда побеждает", либо нужно явно переопределить метод и указать, чей default метод вызывать (InterfaceName.super.method()).
===
CATEGORY: OOP
QUESTION:
Что такое SOLID? (Кратко о каждом принципе).
ANSWER:
S - Single Responsibility (Единственная ответственность).
O - Open/Closed (Открыт для расширения, закрыт для модификации).
L - Liskov Substitution (Подстановка Барбары Лисков: потомки не должны ломать логику родителей).
I - Interface Segregation (Разделение интерфейсов: много узких лучше, чем один общий).
D - Dependency Inversion (Инверсия зависимостей: зависеть от абстракций, а не от деталей).
===
CATEGORY: OOP
QUESTION:
Что такое "хрупкий базовый класс" (Fragile Base Class)?
ANSWER:
Архитектурная проблема, когда изменения в родительском классе (даже безопасные на первый взгляд) приводят к поломке логики в классах-наследниках из-за сильной связности и скрытых зависимостей от реализации родителя.
===
CATEGORY: OOP
QUESTION:
В чем разница между классом и объектом?
ANSWER:
Класс — это шаблон (чертеж), описывающий состояние и поведение, которое будут иметь объекты.
Объект — это конкретный экземпляр класса в памяти, созданный по этому шаблону.
===
CATEGORY: OOP
QUESTION:
Что такое сигнатура метода?
ANSWER:
Сигнатура метода в Java состоит из имени метода и списка типов его параметров. Возвращаемый тип и исключения не входят в сигнатуру.
===
CATEGORY: OOP
QUESTION:
Что такое перегрузка (Overloading) и переопределение (Overriding) методов?
ANSWER:
Overloading: несколько методов в одном классе с одинаковым именем, но разными параметрами (Compile-time полиморфизм).
Overriding: изменение реализации метода родительского класса в классе-наследнике (Runtime полиморфизм).
===
CATEGORY: OOP
QUESTION:
Может ли интерфейс наследовать другой интерфейс?
ANSWER:
Да, интерфейс может наследовать (extends) один или несколько других интерфейсов.
===
CATEGORY: OOP
QUESTION:
Можно ли создать экземпляр абстрактного класса?
ANSWER:
Нет, абстрактные классы не могут быть инстанциированы напрямую. Они предназначены только для наследования.
===
CATEGORY: OOP
QUESTION:
Что такое default методы в интерфейсах и зачем они нужны?
ANSWER:
Методы с реализацией внутри интерфейса. Появились в Java 8 для обеспечения обратной совместимости (чтобы можно было добавлять методы в интерфейсы, не ломая существующие реализации).
===
CATEGORY: OOP
QUESTION:
Что такое static методы в интерфейсах?
ANSWER:
Это методы, принадлежащие самому интерфейсу, а не его реализации. Вызываются через имя интерфейса, не наследуются классами.
===
CATEGORY: OOP
QUESTION:
Что такое маркерный интерфейс?
ANSWER:
Интерфейс без методов и полей. Служит для пометки класса, чтобы сообщить JVM или фреймворку о некотором свойстве (примеры: Serializable, Cloneable, Remote).
===
CATEGORY: OOP
QUESTION:
Что такое функциональный интерфейс?
ANSWER:
Интерфейс, содержащий ровно один абстрактный метод. Может использоваться с лямбда-выражениями. Помечается аннотацией @FunctionalInterface.
===
CATEGORY: OOP
QUESTION:
В чем разница между this и super?
ANSWER:
this — ссылка на текущий объект.
super — ссылка на объект родительского класса (используется для вызова конструкторов или методов родителя).
===
CATEGORY: OOP
QUESTION:
Что такое конструктор? Может ли он быть abstract, static или final?
ANSWER:
Специальный метод для инициализации объекта. Не может быть abstract, static, final или synchronized.
===
CATEGORY: OOP
QUESTION:
Что такое "раннее связывание" и "позднее связывание"?
ANSWER:
Раннее (статическое): метод для вызова определяется на этапе компиляции (перегрузка, static, final, private методы).
Позднее (динамическое): метод определяется во время выполнения на основе реального типа объекта (переопределение).
===
CATEGORY: OOP
QUESTION:
Что такое принцип подстановки Барбары Лисков (LSP)?
ANSWER:
Объекты могут быть заменены их наследниками без изменения корректности программы. Наследник не должен ужесточать предусловия и ослаблять постусловия базового класса.
===
CATEGORY: OOP
QUESTION:
Что такое ковариантность возвращаемых типов при переопределении?
ANSWER:
При переопределении метода в наследнике можно сузить возвращаемый тип (вернуть подкласс того типа, который возвращает родительский метод).
===
CATEGORY: OOP
QUESTION:
Как работают модификаторы доступа при наследовании?
ANSWER:
При переопределении метода нельзя сужать область видимости (например, public -> protected нельзя, protected -> public можно).
===
CATEGORY: OOP
QUESTION:
Что такое Immutable объект? Как его создать в Java?
ANSWER:
Объект, состояние которого нельзя изменить после создания.
Класс final.
Все поля private final.
Нет сеттеров.
В конструкторе — глубокое копирование изменяемых аргументов.
Геттеры возвращают копии изменяемых полей.
===
CATEGORY: OOP
QUESTION:
Что такое POJO (Plain Old Java Object)?
ANSWER:
Обычный Java-объект, не унаследованный от каких-либо специфических классов фреймворков и не реализующий их интерфейсы. Используется для хранения данных.
===
CATEGORY: OOP
QUESTION:
Что такое JavaBeans?
ANSWER:
Стандарт оформления классов:
Класс public.
Конструктор без аргументов (no-args).
Поля private, доступ через геттеры/сеттеры.
Реализует Serializable.
===
CATEGORY: OOP
QUESTION:
Что такое "Diamond Problem" (Проблема ромба)?
ANSWER:
Неоднозначность, возникающая при множественном наследовании, когда класс наследует от двух классов, имеющих общего предка. В Java решена запретом множественного наследования классов и правилами для default методов интерфейсов.
===
CATEGORY: OOP
QUESTION:
В чем суть принципа "Composition over Inheritance"?
ANSWER:
Наследование создает сильную связь и нарушает инкапсуляцию. Композиция позволяет динамически менять поведение (делегирование) и делает дизайн более гибким и тестируемым.
===
CATEGORY: OOP
QUESTION:
Что такое coupling (связность) и cohesion (сцепление)?
ANSWER:
Coupling: степень зависимости между модулями. Хорошо, когда низкая (Low Coupling).
Cohesion: степень, в которой элементы модуля принадлежат друг другу (сфокусированность). Хорошо, когда высокая (High Cohesion).
===
CATEGORY: OOP
QUESTION:
В чем смысл принципа Open/Closed (OCP)?
ANSWER:
Программные сущности должны быть открыты для расширения, но закрыты для модификации. Новое поведение добавляется новым кодом, а не изменением старого.
Из того объема информации, что был в лекциях (а курс довольно обширный и затрагивает много тем), мы покрыли основные моменты по ООП. Однако, чтобы быть уверенным на 100%, давай еще раз "просканируем" материал на предмет более специфических или тонких моментов, которые могли быть упомянуты в контексте ООП, особенно учитывая акцент на "чистый код", "рефакторинг" и "проектирование", которые были в последних лекциях.
===
CATEGORY: OOP
QUESTION:
Что такое принцип YAGNI?
ANSWER:
You Ain't Gonna Need It ("Вам это не понадобится"). Не добавляйте функциональность, пока она действительно не потребуется. Избегайте оверинжиниринга.
===
CATEGORY: OOP
QUESTION:
Что такое принцип DRY?
ANSWER:
Don't Repeat Yourself ("Не повторяйся"). Каждая часть знания должна иметь единственное, непротиворечивое представление в системе. Избегайте дублирования логики.
===
CATEGORY: OOP
QUESTION:
Что такое принцип KISS?
ANSWER:
Keep It Simple, Stupid ("Делай проще, дурачок"). Самое простое решение часто является лучшим. Избегайте ненужной сложности.
===
CATEGORY: OOP
QUESTION:
Что такое Code Smell ("Запах кода")?
ANSWER:
Признаки в коде, которые указывают на возможные проблемы с дизайном или качеством (например, длинные методы, большие классы, дублирование, "божественный объект").
===
CATEGORY: OOP
QUESTION:
Что такое "God Object" (Божественный объект)?
ANSWER:
Антипаттерн. Класс, который знает слишком много или делает слишком много. Нарушает принцип единой ответственности (SRP).
===
CATEGORY: OOP
QUESTION:
Что такое закон Деметры (Law of Demeter)?
ANSWER:
"Не разговаривай с незнакомцами". Объект должен взаимодействовать только с "близкими друзьями" (полями, аргументами метода, созданными объектами), а не лезть во внутренности других объектов (избегать цепочек getA().getB().getC().doSomething()).
===
CATEGORY: OOP
QUESTION:
В чем разница между статической и динамической диспетчеризацией?
ANSWER:
Статическая: выбор метода происходит на этапе компиляции (перегрузка).
Динамическая: выбор метода происходит во время выполнения на основе реального типа объекта (полиморфизм/переопределение).
===
CATEGORY: OOP
QUESTION:
Что такое "Анемичная модель предметной области" (Anemic Domain Model)?
ANSWER:
Антипаттерн (хотя в Spring часто норма), когда объекты данных (Entity) содержат только поля и геттеры/сеттеры, а вся бизнес-логика вынесена в сервисы. Противопоставляется "Богатой модели" (Rich Domain Model), где логика находится внутри сущностей.
===
CATEGORY: OOP
QUESTION:
Что такое GRASP паттерны? (General Responsibility Assignment Software Patterns)
ANSWER:
Набор принципов для распределения ответственности между классами (Information Expert, Creator, Controller, Low Coupling, High Cohesion и др.).
===
CATEGORY: OOP
QUESTION:
В чем разница между "is-a", "has-a" и "uses-a"?
ANSWER:
is-a: Наследование (Кошка — это Животное).
has-a: Композиция/Агрегация (У Машины есть Двигатель).
uses-a: Зависимость (Водитель использует Машину).
===
CATEGORY: OOP
QUESTION:
Что такое Mixin (примесь)? Есть ли они в Java?
ANSWER:
Класс, содержащий методы для использования другими классами без наследования. В Java нет прямых миксинов, но их роль частично выполняют интерфейсы с default методами.
===
CATEGORY: OOP
QUESTION:
Что такое ковариантность и контравариантность в контексте Java Generics?
ANSWER:
Ковариантность (? extends T): можно читать T (Producer), но нельзя писать.
Контравариантность (? super T): можно писать T (Consumer), но при чтении тип Object.
Инвариантность: только конкретный тип T.
===
CATEGORY: OOP
QUESTION:
Что такое Type Erasure (Стирание типов)?
ANSWER:
Процесс, при котором информация о типах дженериков удаляется во время компиляции. В байт-коде дженериков нет, вместо них используются сырые типы (raw types) или границы (bounds).
