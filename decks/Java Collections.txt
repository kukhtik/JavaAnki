ID: 2ba0ee90-f482-4296-8c3b-cef8ca52f94f
CATEGORY: Java Collections
QUESTION:
Назовите основные интерфейсы Java Collections Framework.
ANSWER:
Collection, List, Set, Queue, Deque, Map (Map не наследует Collection, но является частью фреймворка).
===
ID: 694808cb-f648-4e42-afa6-8ef1cdb3769d
CATEGORY: Java Collections
QUESTION:
В чем разница между ArrayList и LinkedList?
ANSWER:
ArrayList: реализован на основе динамического массива. Быстрый доступ по индексу O(1). Медленная вставка/удаление в середину/начало O(N) (сдвиг элементов).
LinkedList: двусвязный список. Медленный доступ по индексу O(N) (перебор). Быстрая вставка/удаление O(1) (если есть ссылка на узел, например через Iterator). Требует больше памяти (хранение ссылок).
===
ID: 50e59301-5ea1-4885-95b8-17cdca1a8730
CATEGORY: Java Collections
QUESTION:
Как устроена HashMap внутри?
ANSWER:
Массив "бакетов" (корзин). Ключ преобразуется в хэш, хэш — в индекс бакета. В бакете хранится связный список (или красно-черное дерево при большом кол-ве коллизий, начиная с Java 8) пар "ключ-значение".
===
ID: 1fc79775-ad27-4d11-b67b-07442001defa
CATEGORY: Java Collections
QUESTION:
Что такое коллизия в HashMap и как она разрешается?
ANSWER:
Ситуация, когда у разных ключей совпадает хэш-код (или индекс бакета).
Разрешается методом цепочек (Chaining): элементы с одинаковым индексом хранятся в связном списке (или дереве) внутри одного бакета.
===
ID: a2ed6040-5a26-4234-87a5-f01adc44bb0b
CATEGORY: Java Collections
QUESTION:
В чем контракт между equals() и hashCode()?
ANSWER:
Если объекты равны по equals(), у них ОБЯЗАТЕЛЬНО должен быть одинаковый hashCode().
Если у объектов одинаковый hashCode(), они НЕ ОБЯЗАТЕЛЬНО равны по equals() (это коллизия).
===
ID: bd73da53-7c33-40cc-bdb5-a7a937545f2d
CATEGORY: Java Collections
QUESTION:
Почему важно переопределять equals() и hashCode() для ключей в HashMap?
ANSWER:
Без переопределения hashCode() вы не найдете бакет, куда положили объект (будет использоваться нативный хэш).
Без переопределения equals() вы не сможете найти конкретный ключ внутри бакета при коллизии (сравнение будет по ссылкам).
В итоге: get() вернет null, хотя объект "логически" есть в мапе.
===
ID: ed8185a5-f31d-4a0d-a8fe-ae43d2c2ad59
CATEGORY: Java Collections
QUESTION:
Что будет, если использовать изменяемый (mutable) объект в качестве ключа HashMap?
ANSWER:
Если после вставки в Map изменить поле ключа, участвующее в hashCode(), то хэш ключа изменится.
При поиске (get) Map будет искать объект в другом бакете (по новому хэшу) и не найдет его. Вернется null. Это причина утечек памяти и багов.
===
ID: b1539e13-d3ca-40e2-9ccb-46289ba08cab
CATEGORY: Java Collections
QUESTION:
Какова временная сложность (Big O) основных операций в HashMap?
ANSWER:
В среднем: O(1) для get и put.
В худшем случае (все ключи попали в один бакет): O(N) для списка или O(log N) для красно-черного дерева (Java 8+).
===
ID: 8fc722ef-f98c-45ab-9ff8-4db87e4b8bec
CATEGORY: Java Collections
QUESTION:
В чем разница между HashMap и Hashtable?
ANSWER:
HashMap: несинхронизирована (быстрее), позволяет null ключи и null значения.
Hashtable: синхронизирована (медленнее, устарела), не позволяет null.
===
ID: 02b12e1e-9f04-4867-b1b6-d065afd5d8fe
CATEGORY: Java Collections
QUESTION:
В чем разница между HashMap и TreeMap?
ANSWER:
HashMap: порядок элементов не гарантируется. Основана на хэшировании. O(1).
TreeMap: элементы отсортированы по ключам (natural order или Comparator). Основана на красно-черном дереве. O(log N).
===
ID: 60529b9f-8fb8-4126-8883-607371aa891e
CATEGORY: Java Collections
QUESTION:
В чем разница между HashSet и TreeSet?
ANSWER:
HashSet: порядок не гарантирован. Внутри использует HashMap. O(1).
TreeSet: хранит элементы в отсортированном порядке. Внутри использует TreeMap. O(log N).
===
ID: 041351c7-63a6-44fc-8d63-1a02c03d0d1d
CATEGORY: Java Collections
QUESTION:
Что такое LinkedHashMap?
ANSWER:
Наследник HashMap. Хранит порядок вставки элементов (insertion order) или порядок доступа (access order). Внутри использует двусвязный список для поддержания порядка.
===
ID: 05942f88-67cf-45cc-9ee0-208b75fc4e61
CATEGORY: Java Collections
QUESTION:
Что такое PriorityQueue?
ANSWER:
Очередь с приоритетом. Элементы извлекаются не в порядке вставки (FIFO), а в соответствии с их приоритетом (сортировкой). Основана на куче (Heap). Сложность вставки/удаления O(log N).
===
ID: e4841b4f-f8b7-4829-bb9d-25d824ed7f25
CATEGORY: Java Collections
QUESTION:
Как сделать коллекцию потокобезопасной (thread-safe)?
ANSWER:
Использовать Collections.synchronizedList/Map/Set (оборачивает методы в synchronized блоке).
Использовать классы из java.util.concurrent: ConcurrentHashMap, CopyOnWriteArrayList (предпочтительнее).
===
ID: 0473132f-d550-4f13-b7c5-39ce52736f4f
CATEGORY: Java Collections
QUESTION:
Как работает ConcurrentHashMap?
ANSWER:
Использует разделение блокировок (Lock Stripping) или CAS (Compare-And-Swap) операции (в Java 8+).
Не блокирует всю мапу целиком при записи (как Hashtable), а блокирует только конкретный бакет (сегмент). Чтение (get) вообще не блокируется.
===
ID: c0f3e166-a7fa-4500-ad36-727ef6a34c21
CATEGORY: Java Collections
QUESTION:
Что такое CopyOnWriteArrayList?
ANSWER:
Потокобезопасный список. При каждой операции изменения (add, set) создает новую копию внутреннего массива.
Идеален для сценария "много чтений, мало записей" (например, список слушателей событий). Чтение очень быстрое (без блокировок).
===
ID: ac7b8b6c-4efd-4384-9ebe-7dfd0b436a19
CATEGORY: Java Collections
QUESTION:
Что такое Fail-Fast и Fail-Safe итераторы?
ANSWER:
Fail-Fast (ArrayList, HashMap): бросают ConcurrentModificationException, если коллекция была изменена структурно (add/remove) во время итерации кем-то, кроме самого итератора.
Fail-Safe (ConcurrentHashMap, CopyOnWriteArrayList): работают с копией данных или в режиме слабой согласованности (weakly consistent), не бросают исключение, но могут не видеть свежих изменений.
===
ID: f1780deb-b76a-44d0-a858-b405abefe1b7
CATEGORY: Java Collections
QUESTION:
Как удалить элемент из списка во время итерации?
ANSWER:
Только через метод Iterator.remove().
Использование List.remove() внутри цикла foreach приведет к ConcurrentModificationException.
С Java 8 можно использовать Collection.removeIf().
===
ID: e77ed038-4d6a-47b6-9be5-b6acb38b4ff2
CATEGORY: Java Collections
QUESTION:
В чем разница между capacity и size в ArrayList?
ANSWER:
Capacity: размер внутреннего массива (сколько памяти выделено).
Size: количество реально хранящихся элементов.
Когда size достигает capacity, происходит ресайз (создается новый массив большего размера, обычно x1.5, и данные копируются).
===
ID: 3ca98141-2f24-4321-8645-b3f80e8b06a6
CATEGORY: Java Collections
QUESTION:
Какая сложность вставки в середину ArrayList?
ANSWER:
O(N), так как необходимо сдвинуть все последующие элементы вправо на одну позицию.
===
ID: 1f386ade-7378-4558-9dee-9b5f5a3fa82d
CATEGORY: Java Collections
QUESTION:
Почему ArrayDeque быстрее Stack и LinkedList (как очереди)?
ANSWER:
Stack устарел (синхронизирован).
LinkedList создает объект-узел (Node) для каждого элемента (нагрузка на GC, лишняя память).
ArrayDeque использует массив, лучше локальность кэша процессора, нет лишних аллокаций.
===
ID: 6b8a7c2e-1946-42dc-8233-5d05e1fddba7
CATEGORY: Java Collections
QUESTION:
Зачем нужен метод Collections.unmodifiableList()?
ANSWER:
Создает обертку (View), которая запрещает модификацию коллекции (add/remove бросают UnsupportedOperationException). Полезно для защиты инкапсуляции при возврате списка из геттера.
(Важно: если изменить исходный список, изменения будут видны и через unmodifiable обертку).
===
ID: b31cfb7a-8cff-47ee-b29c-bf71a68f4600
CATEGORY: Java Collections
QUESTION:
Что такое List.of(), Set.of(), Map.of() (Java 9+)?
ANSWER:
Фабричные методы для создания неизменяемых (immutable) коллекций.
Они действительно неизменяемые (нет связи с исходным массивом).
Не допускают null элементов.
Эффективны по памяти.
===
